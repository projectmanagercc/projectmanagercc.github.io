软件危机提出近60年了，如今这个危机解决了吗？

大局上来说，显然没有。

我们在这60多年的历程中，有了不少新的工具和方法，比如结构化设计、面对对象设计、项目管理WBS、需求工程，数以千计的计算机语言，瀑布方法和敏捷系列的几十种方法，UML和相应的软件过程方法，大量的关系数据库和非关系数据库，优良的操作系统。

对了，还有重构，XP。

但是软件危机依然大量存在。

当年提出的软件危机的问题包括：

- 项目运行超出预算。
- 项目运行超过时间。
- 软件质量低落。包括软件通常不符合需求，项目无法管理，且代码难以维护


行业的标杆企业微软可以说明很多问题。2000年前后，微软出版了一批项目管理的书籍，可以让外人看到微软内部的项目状况，我知道很多MS的软件都饱受软件危机的折磨。最典型突出的就是Vista，历时五年，出来一个广受诟病的OS，Vista被寄以厚望的若干大的特性，都没有发布或者阉割发布。

有赞的白呀说他们的系统做了十年，有2万个功能，每一个功能都是需要的。引入一个新的功能，解决了5%的客户的需求，但是让95%的用户感到难用。

我知道很多企业也是这样的。

然而，确实在浩如烟海的失败项目中，有些少量的成功项目，回转的透漏一些成功的规律给我们。

“提高需求价值的一个方法：采用固定短迭代周期实践，来引发需求价值的自我竞争，从而提升当前迭代的需求价值”

我听说过一个关于excel开发的故事。说当年开发excel有600个特性，每一个都很重要，但是他们的时间限定为一年，他们不得不舍弃一些特性，去做400个特性。当他们完成开发后，他们发现那没有做的200的特性大部分不需要做，没有价值或者已经完成。

很多事情都是真正做过才知道价值，所以即便如微软这样的人力资源充沛的企业，也无法做法未卜先知。所以这些需求的价值无论做之前被什么样的人肯定和赞美，都可能在完成后发现并无价值。

具体而言，无论产品经理认为他们的需求是多么重要，都必须和自己的其他需求一起对比，从中找到最重要的。然后只开发这些最重要的。也就是需求的自我竞争后给出当前迭代的需求清单。

开发团队如何促成这个自我竞争？就是固定小周期迭代。小周期迭代导致需求必须可以适配到当前迭代内，否则就必须放到下一个迭代考虑。开发过程就是一个容器，需求都是有大有小但是他们必须装入容器。而不是需求只要有，就一定要一次装完，不行就改大容器，也就是无限制的增加项目时间。

固定小周期迭代的好处：

1. 每次迭代，都是尽快把最重要的功能发布给客户
2. 最重要的有产品需求排序，形成自我竞争，从而提升需求的价值和质量
3. 需求风险最大化也就是一个迭代的影响，不至于毁掉一年甚至更久的时间

反过来

1. 每次都做全部需求，所以不管什么需求，不管重要与否，都需要很长时间才见客户
2. 就会导致需求价值的良莠不齐，产品需求部门不会认真考虑需求价值，因为都会做。
3. 需求风险最大化会浪费掉一年甚至更久的时间

这个故事的核心思想与软件开发中的“最小可行产品”（MVP）概念相呼应。MVP即在产品开发的早期阶段，专注于最基本的功能集，以快速推向市场并收集用户反馈，而不是试图一次性开发一个具有所有理想特性的完整产品。但是固定小周期不仅仅是开发的早期阶段，而是每一个迭代都一如既往的总有的不断的排序，在有限的时间内提交最重要的功能给客户。

然而，有一些项目，并不存在需求的贪婪，但是依然一再重写，是为什么？

我自己看到的情况，就是我创始后开发的一个商业软件，之后转交给子公司的一个软件，从2011年开发到2022年，已经完全重写5次，每两年重写一次。

每一次的理由都是一样的。就是维护不下去了。当然从转交出来后，我看到他们每一次发布都延迟，每一次都说先赶出来再说，并且每一个功能都是需要的。然后赶出来后就快速的进入报废的循环。

原因很简单，之前维护不下去的产品的原因没有解决，因此就会一再重犯相同的问题。

比如我知道很多产品都存在的大函数，一个函数几千甚至几万行。这样的函数显然缺乏任何的结构化，也没有任何的面向对象化这样的分而治之的方法，和现代程序设计无缘。所有软件危机提出以来，为了解决软件危机而引入的方法，实践在在这样的产品设计中没有任何体现，当然也就不可能度过软件危机。


至于时间上的延期，可以通过WBS的方式，分解时间的压力到每一个研发人员的头上。通过每一个研发人员的细颗粒度时间估计，达到整体时间估计的粗颗粒度估计的准确性。这个另外细说。

所以，解决软件危机的方法，我所实践到的，就是

1. 通过引入自我竞争，提升需求质量
2. 通过引入软件工程化方法，包括重构、结构化和面向对象设计，在空间维度上，达到复杂度的分而治之。
3. 通过WBS，引入时间维度上的分而治之
